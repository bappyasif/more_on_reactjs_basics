Commonly Used Lifecycle Methods:
    <> render: is only required method in a class component, when called, it should examine props and state and return one of these following types:
        <> React elements: typically created via JSX (e.g. <div />, <SomeComponent />) are react elements that instructs react to render a DOM node, or another user defined component
        <> Arrays and fragments: lets us return multiple elements from render
        <> Portals: lets us render children into a different DOM subtree
        <> String and numbers: these are rendered as text nodes in DOM
        <> Booleans or null: render nothing (e.g. mostly exists to support return 'test' && <Component /> pattern, where 'test' is boolean)
    render method should be pure, mean ig doesn noit modify component state, and returns same output for same input always, and it does not directly interact with browser, if we need to interact with browser, we should use componentDidMount or other methods instead, keeping render method pure makes it easy to reason about, also, render will not be invoked if shouldComponentUpdate method returns false

    <> Constructor: if we dont initialize state and don't bind methods, we dont need to implement a constructor in components, constructor is called before it is mounted, when implementing constructor for a react.component subclass, we should call super(props) before anyother statements, otherwise this.props will be undefined in constructor, which can leads to bugs, typically constructors are only used for these two purposes:
        <> initializing local state by assigning an object to this.state
        <> binding event handler methods to an instance
    we should not call setState in constructor, instead assign initial state to this.state directly in constructor an dis only place where we should directly assign value to this.state in other methods we shall always use this.setState instead, also not to introduce any kind of side effect related code within constructor, for those use cases we can use componentDidMount,
    also avoid copying props into state, this is a common mistake, because we can directly acess props, withiout have to use it in state variable, which creates bugs, because props.value wont be reflected in this state variable, when we need to ignore prop updates then we can use this pattern, but it's always preferable to use controlled or uncontrolled with a key, way of accessing state values.

    <> componentDidMount: is invoked immediately after component is mounted into DOM tree, to make any network request, this is a good place as any, also for setting up subscriptions, when we do that, we should also unsubscribe it from componentWillUnmount, we may call setState, which will cause rendering but it'll happen bedoew browser updates screen, meaning even though browser renders twice user wont see immediate state, it can however be necessary for cases like modals and tooltips whe we need to measure a DOM node before rendering, something that depends on its size or position.

    <> componentDidUpdate: is invoked immediately after any update occurs, this method is not called in initial render, when DOM gets updated we can use this method, this is also a good place to make network requests, as long as we compare current props to previous changes otherwise no network request may be necessary,
    we may call setState but it has to be wrapped within a conditional check otherwise it cause infinite loop, it would also cause an extra re rendering which will not visible to user can affect component performance, gain to mirror some state to a prop from container component, consider using props instead, also, if our component uses getSnapshotBeforeUpdate() lifecycle, value it returns will be passed as a third "snapshot" parameter componentDidUpdate, otherwise this parameter will be "undefined", anf if we use shouldComponentUpdate() and if it returns false then componentDidUpdate will not be rendered

    <> componentWillUnmount: is invoked before a component is  unmounted and destroyed, any necessary cleanup goes into this method, such as invalidating timers, canceling network request or cleaning up any subscriptions that were created in componentDidMount(), we should not call setState in this method, because component will never be re rendered, once a component is unmounted it will never be mounted again

Rarely used lifecycle methods:
    <> shouldComponentUpdate: is used, to let react know if a component's output is not affected by current change in state or props, default behavior is to re render on every change and in vast majority of cases we should rely on this behavior, this method is not called for initial render or forceUpdate, this method mostly used in performance optimization, it can not always prevent rerendering, we cn consider PureComponent instead of wrigting shouldComponentUpdate method by hand, PureComponent performs a shallow comparison of props and state and reduces chance that you'll skip a necessary update, in that method, we may compare props with nextProps and this.state with nextState an dreturn false to let react know that update can be skipped, returning false fro this metod does not stop child component from re rendering when their state changes, avoid using JSON.stringify() in this method, it will harm performance, currently, if it returns false then render and componentDidUpdate will not be invoked, in future this behavior might changeresulting rendering of component

    <> static getDerivesStateFromProps: is invoked right before calling render(), both on initial mount and on subsequent updates, it should return an object to update state or null to update nothing, used rarely when state depends on changes in props over time (e.g. to deceide to animate in or out after comparisons), this method does not have access to component instance, we could extract pure functions of component outside class to access them with this method, its rendered on every cycle, regardless of cause, UNSAFE_componentWillReceiveProps, which only fires when parent causes a rerender and not as a result of a local setState()

    <> getSnapshotBeforeUpdate: is invoked before most recently rendered output is committed to DOM, it enables component to capture some information from DOM, such as scroll position, before it is poterntially changed, any value returned by this lifecycle method will be passed as a parameter to componentDidUpdate, it may be used in UI like a chat thread tha needs to handle scroll position in a special way, a snapshot value or null should be returned


<> Error boundaries: are react components that catches JS errors anywhere in their sub/components tree, log those erros and display a fallback UI instead of component tree that crashed, it catches errors during rendering and in constructors of whole tree below them, a class component becomes an error boundary, if it defines either or both of these methods, static getDerivedStateFromError, componentDidCatch(), updating state from these lifecycles lets us capture an unhandled JS error in below tree and display a fallback UI, use'em for recovering from unexpected exceptions, but not for flow control, error boundaries only catch errors in components below them in tree, an error boundary can't catches error within itself
    <> static getDerivedStateFromError: is invoked after an error has been thrown by a descendant component, it recieves error that was thrown as a parameter and should returna a value to update state, it's called during "render", so no side effects are allowed, for those use cases, componentDidCatch should be used.

    <> componentDidCatch: is ionvoked after an error thrown by a dexcendant component, it recieves two parameters, "error" - error that waqs thrown, "info" - an object with a componentStatck key containing which component threw that error, it is called during "commit/mounting" so side effects are allowed, it should be used for logging errors, this method wroks differently for for productions and development mode,
    in development mode, errors will bubble up to "window", this means that any "error callback" will intercept errors that have been caught by this method, where as, in productions mode, error will not bubble up, any ancestor error handler will only recieve errors not explicitly caught by componentDidCatch() outside of it's boundaries, in event of an error we can render a fallback UI with componentDidCatch by calling setState, in fiture release this might be depricated, so using static getDerivesStateFromError() is way to go, to handle fallback rendering instead.